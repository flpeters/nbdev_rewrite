# AUTOGENERATED! DO NOT EDIT! File to edit: 00_export.ipynb (unless otherwise specified).

__all__ = ['find_exports', 'KeywordParser', 'read_nb', 'iter_comments', 'ExportCache', 'OptionsTuple', 'add_names', 'kw_export', 'keyword_parser', 'not_private', 'find_default_export', 'kw_hide', 'update_recursive', 'update_from_all_', 'legacy_parse_options', 'find_names', 'parse_options', 'notebook2script', 'create_mod_file', 'unwrap_attr']

# Cell
from collections import namedtuple, defaultdict
import os
import re
from nbdev_rewrite.imports import *

# Cell
def read_nb(fname):
    "Read the notebook in `fname`."
    with open(Path(fname),'r', encoding='utf8') as f: return nbformat.reads(f.read(), as_version=4)

# Cell
# TODO(florian): Only look for 0 indent comments?
def iter_comments(src:str, pure_comments_only:bool=True, line_limit=None):
    """Detect all comments in a piece of code, excluding those that are a part of a string."""
    in_lstr = in_sstr = False
    count, quote = 1, ''
    for i, line in enumerate(src.splitlines()[:line_limit]):
        is_pure, escape, prev_c = True, False, '\n'
        for j, c in enumerate(line):
            # we can't break as soon as not is_pure, because we have to detect if a multiline string beginns
            if is_pure and (not (c.isspace() or c == '#')): is_pure = False
            if (in_sstr or in_lstr):
                # assert (in_sstr and not in_lstr) or (in_lstr and not in_sstr)
                if escape: count = 0
                else:
                    if (c == quote):
                        count = ((count + 1) if (c == prev_c) else 1)
                        if in_sstr: in_sstr = False
                        elif (in_lstr and (count == 3)): count, in_lstr = 0, False
                escape = False if escape else (c == '\\')
            else:                    
                if (c == '#'):
                    if (pure_comments_only and is_pure): yield (line, (i, j))
                    elif (not pure_comments_only):       yield (line[j:], (i, j))
                    break
                elif c == "'" or c == '"':
                    count = ((count + 1) if (c == prev_c) else 1)
                    if count == 1: in_sstr = True
                    elif count == 3: count, in_lstr = 0, True
                    else: raise SyntaxError(f'Unexpected quote repetition count: {count} Should be either 1 or 3')
                    quote = c
            prev_c = c

# Cell
class KeywordParser:
    def __init__(self, *init_keywords):
        self.parsers = {}
        for kw in init_keywords: self.parsers[kw] = self._create_parser(kw)

    def _create_parser(self, keyword):
        # TODO: decide on the syntax
        # TODO: Should there be any whitespace allowed before special comments?
        # TODO: Should more than one "#" be allowed for special comments?
        pattern = fr"""
        ^              # start of line, since MULTILINE is passed
        \s*            # any amount of whitespace
        \#+\s*          # literal "#", then any amount of whitespace
        {keyword}(.*)  # keyword followed by arbitrary symbols (except new line)
        $              # end of line, since MULTILINE is passed
        """
        return re.compile(pattern, re.IGNORECASE | re.MULTILINE | re.VERBOSE)

    def __getitem__(self, key):
        if key in self.parsers: return self.parsers[key]
        else:
            parser = self._create_parser(key)
            self.parsers[key] = parser
            return parser

# Cell
OptionsTuple = namedtuple(typename='Options',
                          field_names=['internal', 'export_target'],
                          defaults=[False, None])

# Cell
_re_legacy_options = re.compile(r'^(i)?\s*([a-zA-Z0-9]+\S*|)\s*$')
def legacy_parse_options(options:str) -> OptionsTuple:
    res = _re_legacy_options.search(options)
    if res:
        internal, export_target = res.groups()
        return OptionsTuple(internal=(internal == 'i'),
                            export_target=(os.path.sep.join(export_target.split('.')) if export_target else None))
    else: return None

# Cell
def parse_options(options:str, legacy:bool=True) -> OptionsTuple:
    if (options is None) or (options == '') or (options.isspace()): return OptionsTuple()
    else:
        if legacy:
            res = legacy_parse_options(options)
            if res: return res
            else: pass # Fall through to different parsing scheme
        # TODO: New Syntax for specifying keyword options
        raise NotImplementedError('this branch of parse_options() is not implemented yet.')

# Cell
keyword_parser = KeywordParser()
kw_export, kw_hide = keyword_parser['export'], keyword_parser['hide']
def find_exports(cells:list, default:str, code_only:bool=True) -> list:
    """check for each cell if it's supposed to be exported and aggregate cell content together with export options"""
    exports = []
    for i, cell in enumerate(cells):
        if code_only and (cell.cell_type != 'code'): continue
        else:
            source = cell.source
            for comment, (loc_line, loc_char) in iter_comments(source):
                res = kw_export.search(comment)
                if res:
                    options = parse_options(res.groups()[0])
                    assert options.export_target or default, f'Cell nr.{i} doesn\'t have an export target, \
                                                                and no default is specified:\n{source}'
                    if not options.export_target: options = options._replace(export_target=default)
                    source = remove_comment(source, loc_line, None)
                    # source = re.sub(r'\s+$', '', source, flags=re.MULTILINE) # remove whitespace at the end of each line
                    exports.append((source, options))
                    continue
                if kw_hide.search(comment): break
    return exports

# Cell
import ast
from ast import iter_fields, AST
import _ast

# Cell
def unwrap_attr(node:_ast.Attribute) -> str:
    if isinstance(node.value, _ast.Attribute): return '.'.join((unwrap_attr(node.value), node.attr))
    else: return '.'.join((node.value.id, node.attr))

# Cell
def update_recursive(node, names):
    """inplace, recursive update of names"""
    if   isinstance(node, _ast.Name)      : names.append(node.id)
    elif isinstance(node, _ast.Starred)   : names.append(node.value.id)
    elif isinstance(node, _ast.Attribute) : names.append(unwrap_attr(node))
    elif isinstance(node, (_ast.List, _ast.Tuple)):
        for x in node.elts: update_recursive(x, names)
    elif isinstance(node, list):
        for x in node: update_recursive(x, names)
    else: raise SyntaxError(f'Can\'t resolve {node} to name, unknown type')

# Cell
def update_from_all_(node, names): # TODO(florian): should all of these cases be handled?
    """inplace, recursive update of names, by parsing the right side of a _all_ variable"""
    if isinstance(node, _ast.Str): names.add(node.s)
    elif isinstance(node, _ast.Name): names.add(node.id)
    elif isinstance(node, _ast.Attribute): names.add(unwrap_attr(node))
    elif isinstance(node, (_ast.List, _ast.Tuple, _ast.Set)):
        for x in node.elts: update_from_all_(x, names)
    elif isinstance(node, _ast.Starred): raise SyntaxError(f'Starred expression *{node.value.id} not allowed in _all_')
    else: raise SyntaxError(f'Can\'t resolve {node} to name, unknown type')

# Cell
def not_private(name): return not (name.startswith('_') and (not name.startswith('__')))

# Cell
def add_names(node, names):
    tmp_names = list()
    update_recursive(node.targets, tmp_names)
    for name in tmp_names:
        if not_private(name): names.add(name)
        # NOTE: cases below can only use private variable names
        elif name == '_all_':
            assert len(tmp_names) == 1, 'reserved keyword _all_ can only be used in simple assignments'
            update_from_all_(node.value, names)

# Cell
def find_names(code:str) -> list:
    try: tree = ast.parse(code) # expensive # TODO: make this use the python version specified in config
    except Exception as e: raise e # TODO: Logging
    else:
        names = set()
        for node in tree.body:
            if   isinstance(node, _ast.Assign): add_names(node, names)
            elif isinstance(node, (_ast.FunctionDef, _ast.ClassDef)) and not_private(node.name): names.add(node.name)
            else: pass
        return names

# Cell
class ExportCache(defaultdict):
    def __init__(self, default_export:str=None):
        super(ExportCache, self).__init__(self._create_exp)
        self.tupletype = namedtuple(typename='export', field_names=['code', 'names'])
        if default_export is not None: self[default_export]
    
    def _create_exp(self): return self.tupletype(code=list(), names=set())
    
    def add_names(self, key:str, names:list): self[key].names.update(names)
            
    def add_code(self , key:str, code:str)  : self[key].code.append(code)

# Cell
def find_default_export(cells:list) -> str:
    # search through all cells to find the default_exp keyword and return it's value.
    # syntax checking
    # maybe do some sanity checking
    default = 'export'
    return default

# Cell
def create_mod_file(orig_nbfname, targ_pyfname):
    # create the .py file in the correct folder, with a header saying where it was originally from
    pass

# Cell
def _notebook2script(fname=None, cells=None, silent=False, to_dict=False):
    """Convert a single notebook"""
    fname = Path(fname)
    assert (fname and not cells) or (not fname and cells)
    if not cells: # TODO(florian): this is temporarily used for testing, remove this
        nb = read_nb(fname)
        cells = nb['cells']
        
    sep = '\n' * (max(int(Config().get('cell_spacing', 1)), 0) + 1)
    
    default = find_default_export(cells)
    if default is None:
        print('WARNING: No default export target found! (should this crash, or see if each export has its own target?)')
        raise NotImplementedError('Not specifying a default export is not supported yet.')
    else:
        default = os.path.sep.join(default.split('.'))
        ec = ExportCache(default)
        # TODO(florian): create_mod_file(original_nbfile_path, target_pyfile_path) # args flipped in original code
        pass
    # TODO(florian): load _nbdev file and create a spec from it (no idea why this is needed)
    
    exports = find_exports(cells, default)
    for j, (code, options)  in enumerate(exports):
        # code = clean_code(code)
        # TODO: make imports of the current project relative in the output code
        i, e = options.internal, options.export_target
        if not i: ec.add_names(e, find_names(code))
        orig = (('Internal C' if i else '# C') if e==default else f'# Comes from {fname.name}, c') + 'ell\n'
        ec.add_code(e, (sep + orig + code))
        
    for e, s in ec.items():
        fname_out = Config().lib_path/f'{e}.py'
        nb_path = Config().nbs_path/f'{fname}'
        config_path = Config().config_file.parent
        rel_nb_path = os.path.relpath(nb_path, config_path).replace('\\', '/')
        fname_out.parent.mkdir(parents=True, exist_ok=True)
        warning = f'# AUTOGENERATED! DO NOT EDIT! File to edit: {rel_nb_path} (unless otherwise specified).'
        names = sep + "__all__ = ['" + "', '".join(s.names) + "']" # TODO(florian): add line breaks at regular intervals
        code  = ''.join(s.code)
        file_content = warning + names + code
        if e == default:
            with open(fname_out, 'w', encoding='utf8') as f: f.write(file_content)
        else: raise NotImplementedError('Exporting to a module other than the default is not supported yet.')
    # TODO(florian): add names to _nbdev index
    # TODO(florian): write code cell to file
    # TODO(florian): save _nbdev file
    return ec

# Cell
def notebook2script(fname=None, silent=False, to_dict=False):
    "Convert notebooks matching `fname` to modules"
    # initial checks
    if os.environ.get('IN_TEST',0): return  # don't export if running tests
    if fname is None:
        reset_nbdev_module()
        update_version()
        update_baseurl()
        files = [f for f in Config().nbs_path.glob('*.ipynb') if not f.name.startswith('_')]
    else: files = glob.glob(fname)
    d = collections.defaultdict(list) if to_dict else None
    for f in sorted(files): d = _notebook2script(f, silent=silent, to_dict=d)
    if to_dict: return d
    else: add_init(Config().lib_path)