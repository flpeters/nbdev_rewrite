# AUTOGENERATED! DO NOT EDIT! View info comment on each cell for file to edit.


# Cell nr. 39; Comes from '00_export_v4.ipynb'
# This Flag allows anyone to know if this Module exists in their namespace
MODULE__IMPORTS__FLAG = None


# Cell nr. 40; Comes from '00_export_v4.ipynb'
import os,re,functools
import concurrent.futures
from threading import Thread
from queue import Queue
from configparser import ConfigParser
from pathlib import Path
from collections import OrderedDict
# from nbformat.sign import NotebookNotary
# from base64 import b64decode,b64encode
# from types import MethodType,FunctionType


# Cell nr. 42; Comes from '00_export_v4.ipynb'
def test_eq(a,b): assert a==b, f'{a}, {b}'


# Cell nr. 44; Comes from '00_export_v4.ipynb'
def save_config_file(file, d, **kwargs):
    "Write settings dict to a new config file, or overwrite the existing one."
    config = ConfigParser(**kwargs)
    config['DEFAULT'] = d
    config.write(open(file, 'w'))


# Cell nr. 45; Comes from '00_export_v4.ipynb'
def read_config_file(file, **kwargs):
    config = ConfigParser(**kwargs)
    config.read(file)
    return config


# Cell nr. 46; Comes from '00_export_v4.ipynb'
_defaults = {"host": "github", "doc_host": "https://%(user)s.github.io", "doc_baseurl": "/%(lib_name)s/"}

def _add_new_defaults(cfg, file):
    "If an existing Config does not contain these values, add them, and save the config file.\n"\
    "This is meant to be used in case new default values are added in later versions."
    for k,v in _defaults.items():
        if cfg.get(k, None) is None:
            cfg[k] = v
            save_config_file(file, cfg)


# Cell nr. 47; Comes from '00_export_v4.ipynb'
@functools.lru_cache(maxsize=None)
class Config:
    "Store the basic information for nbdev to work"
    def __init__(self, cfg_name='settings.ini'):
        cfg_path = Path.cwd().absolute().resolve()
        while cfg_path != cfg_path.parent and not (cfg_path/cfg_name).exists(): cfg_path = cfg_path.parent
        self.config_path,self.config_file = cfg_path,cfg_path/cfg_name
        assert self.config_file.exists(), f"Could not find {cfg_name}"
        self.d = read_config_file(self.config_file)['DEFAULT']

    def __getattr__(self,k):
        if k.endswith('_path'): return self._path_to(k)
        try: return self.d[k]
        except KeyError: raise AttributeError(f"Config ({self.config_file.name}) has no attribute '{k}'") from None
    
    def _path_to(self,k,default=None):
        v = self.d.get(k, default)
        if v is None: raise AttributeError(f"Config ({self.config_file.name}) has no attribute '{k}'")
        return self.config_path/v
    
    def path_to(self,k,default=None):
        "Retrieve a path saved in Config relative to the folder the Config file is in."
        return self._path_to((k if k.endswith('_path') else k+'_path'), default)

    def get(self,k,default=None): return self.d.get(k, default)
    def __setitem__(self,k,v): self.d[k] = str(v)
    def __contains__(self,k):  return k in self.d
    def save(self): save_config_file(self.config_file,self.d)


# Cell nr. 48; Comes from '00_export_v4.ipynb'
def create_config(lib_name,
                  cfg_path='.', cfg_name='settings.ini',
                  license=None,
                  author=None, author_email=None, copyright=None,
                  nbs_path='nbs',
                  lib_path='%(lib_name)s', doc_path='docs',
                  version='0.0.1', min_python='3.7',
                  language='English', status=None,
                  audience=None, title='%(lib_name)s',
                  description=None, keywords=None,
                  requirements=None, console_scripts=None, dep_links=None,
                  git_user=None, host='github', branch='master',
                  git_url='https://github.com/%(git_user)s/%(lib_name)s/tree/%(branch)s/',
                  doc_host='https://%(git_user)s.github.io',
                  doc_baseurl='/%(lib_name)s/',
                  repo_name=None, company_name=None,
                  **kwargs):
    if git_user is None: host = branch = git_url = doc_host = doc_baseurl = None
    else: user = git_user # NOTE: backwards compatibility
    args = locals()
    path = args.pop('cfg_path')
    name = args.pop('cfg_name')
    kwargs = args.pop('kwargs') # NOTE: locals() also contains `kwargs` as a key, so remove it
    config = OrderedDict(filter(lambda x: x[1] is not None, # NOTE: Filter out None values
                                sorted({**args, **kwargs}.items(),
                                       key=lambda x:x[0]))) # NOTE: Sort by key
    save_config_file(Path(path)/name, config)


# Internal Cell nr. 49; Comes from '00_export_v4.ipynb'
create_config.__doc__ = """
Create a new config file and save it.

Parameters
----------
`lib_name` : str
    The name of the package that will be created

`cfg_path` : str, optional
    The path where to create the config file.
`cfg_name` : str, optional
    The name of the config file to be created.
    
`license` : {'apache2', }, optional
    The license under which this project is published.
`author` : str, optional
    The name of the author of this project (probably you).
`author_email` : str, optional
    The authors email address.
`copyright` : str, optional
    The authors name, or a company name.

`nbs_path` : str, optional
    A path to a subdirectory relative to where the 'settings.ini' file is located.
    All of the notebooks that you want to have processed need to be in this folder,
    or in a subfolder.
`lib_path` : str, optional
    A path to a subdirectory relative to where the 'settings.ini' file is located.
    This is the folder where all generated .py files will be stored,
    and the name you use when importing the package.
`doc_path` : str, optional
    A path to a subdirectory relative to where the 'settings.ini' file is located.
    Present for compatibility with the original 'nbdev' project. This folder is
    where documentation generated from your notebooks in `nbs_path` is stored.

`version` : str, optional
    A version number in the '{major}.{minor}.{patch}' semantic versioning format.
`min_python` : {..., '3.6', 3.7', '3.8', '3.9', ...}, optional
    The minimum python version necessary to run your code [1].
`language` : {'English', ...}, optional
    The natural language used in your program [1].
`status` : {'1', '2', '3', '4', '5', '6', '7'}, optional
    The development status of your project [1].
    The numbers 1-7 correspond to the following status respectively:
    Planning, Pre-Alpha, Alpha, Beta, Production, Mature, Inactive
`audience` : {'Developers', 'End Users/Desktop', 'Other Audience', ...}, optional
    The intended audience of your project [1].
`title` : str, optional
    By default the same as your library name.
    Currently only used by the original nbdev project.
`description` : str, optional
    A short, one sentence, description of your project.
`keywords` : str, optional
    Space separated keywords / tags that describe your project.
    e.g. 'python jupyter notebook nbdev'.

`requirements` : str, optional
    Packages that are minimally required for your project to run.
    Written in the same format as setuptools requirements [2].
`console_scripts` : str, optional
    Space separated list of key=value pairs.
    The key is the name of the command,
    and value is the python module and function that is supposed to be called.
    Written in the same format as setuptools console-scripts [3].
`dep_links` : str, optional
    Currently not in use.
    Written in the same format as setuptools dependency links.

`git_user` : str, optional
    Your git username.
`host` : str, optional
    The name of your git repo host.
`branch` : str, optional
    The name of the main git branch.
`git_url` : str, optional
    The git URL where your project lives.

`doc_host` : str, optional
    The URL where you have documentation hosted.
`doc_baseurl` : str, optional
    The URL path relative to the `doc_host`,
    which points to where the docs for this project are stored.

`repo_name` : str, optional
    For enterprise git users.
`company_name` : str, optional
    For enterprise git users.

Returns
-------
None

See Also
--------
[1] https://pypi.org/classifiers/
[2] https://packaging.python.org/discussions/install-requires-vs-requirements/
[3] https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html
"""


# Cell nr. 52; Comes from '00_export_v4.ipynb'
def in_ipython():
    "Check if the code is running in the ipython environment (jupyter including)"
    program_name = os.path.basename(os.getenv('_', ''))
    if ('jupyter-notebook' in program_name or # jupyter-notebook
        'ipython'          in program_name or # ipython
        'JPY_PARENT_PID'   in os.environ):    # ipython-notebook
        return True
    else: return False
IN_IPYTHON = in_ipython()


# Cell nr. 53; Comes from '00_export_v4.ipynb'
def in_colab():
    "Check if the code is running in Google Colaboratory"
    try:
        from google import colab
        return True
    except: return False
IN_COLAB = in_colab()


# Cell nr. 54; Comes from '00_export_v4.ipynb'
def in_notebook():
    "Check if the code is running in a jupyter notebook"
    if in_colab(): return True
    try:
        shell = get_ipython().__class__.__name__
        if shell == 'ZMQInteractiveShell': return True   # Jupyter notebook, Spyder or qtconsole
        elif shell == 'TerminalInteractiveShell': return False  # Terminal running IPython
        else: return False  # Other type (?)
    except NameError: return False      # Probably standard Python interpreter
IN_NOTEBOOK = in_notebook()


# Cell nr. 56; Comes from '00_export_v4.ipynb'
def num_cpus():
    "Get number of cpus"
    try:                   return len(os.sched_getaffinity(0)) # NOTE: not available on all platforms
    except AttributeError: return os.cpu_count()


# Cell nr. 57; Comes from '00_export_v4.ipynb'
class ProcessPoolExecutor(concurrent.futures.ProcessPoolExecutor):
    "Like `concurrent.futures.ProcessPoolExecutor` but handles 0 `max_workers`."
    def __init__(self, max_workers=None, on_exc=print, **kwargs):
        self.not_parallel = max_workers==0
        self.on_exc = on_exc
        if self.not_parallel: max_workers=1
        super().__init__(max_workers, **kwargs)

    def map(self, f, items, *args, **kwargs):
        g = functools.partial(f, *args, **kwargs)
        if self.not_parallel: return map(g, items)
        try: return super().map(g, items)
        except Exception as e: self.on_exc(e)


# Cell nr. 58; Comes from '00_export_v4.ipynb'
def parallel(f, items, *args, n_workers=None, **kwargs):
    "Applies `func` in parallel to `items`, using `n_workers`"
    if n_workers is None: n_workers = min(16, num_cpus())
    with ProcessPoolExecutor(n_workers) as ex:
        r = ex.map(f,items, *args, **kwargs)
        return list(r)


# Cell nr. 59; Comes from '00_export_v4.ipynb'
# https://github.com/justheuristic/prefetch_generator
class BackgroundGenerator(Thread):
    "Computes elements of a Generator in a background Thread."
    def __init__(self, generator, max_prefetch:int=-1):
        """
        `generator`: A Generator to wrap and prefetch from in a separate thread.
        `max_prefetch`: How many items to maximally prefetch at any given time.
        If `max_prefetch` is <= 0, then the queue size is infinite.
        """
        super().__init__()
        self.queue, self.generator, self.daemon = Queue(max_prefetch), generator, True
        self.start()
    
    def run(self):
        try:
            for item in self.generator: self.queue.put(item)
        except Exception as e:
            print('WARNING: Failed in BackgroundGenerator Thread!')
            raise e
        finally: self.queue.put(StopIteration)
    
    def __iter__(self): return self
    def __next__(self):
        next_item = self.queue.get()
        if next_item is StopIteration: raise StopIteration
        return next_item


# Cell nr. 60; Comes from '00_export_v4.ipynb'
def prefetch(max_prefetch:int=-1):
    """
    Decorator for wrapping a `yield`-ing Function with `BackgroundGenerator`,
    which computes elements of the generator in a background Thread.
    
    A new instance of `BackgroundGenerator` is created every time the decorated function is called.
    
    `max_prefetch`: How many items to maximally prefetch at any given time.
    If `max_prefetch` is <= 0, then the queue size is infinite.
    """
    def decorator(generator):
        def wrapper(*args,**kwargs):
            return BackgroundGenerator(generator(*args,**kwargs), max_prefetch=max_prefetch)
        functools.update_wrapper(wrapper, generator)
        return wrapper
    return decorator


# Cell nr. 62; Comes from '00_export_v4.ipynb'
class ReLibName():
    "Regex expression that's compiled at first use but not before since it needs `Config().lib_name`"
    def __init__(self, pat, flags=0): self._re,self.pat,self.flags = None,pat,flags
    @property
    def re(self):
        if not hasattr(Config(), 'lib_name'): raise Exception("Please fill in the library name in settings.ini.")
        self.pat = self.pat.replace('LIB_NAME', Config().lib_name)
        if self._re is None: self._re = re.compile(self.pat, self.flags)
        return self._re


# Cell nr. 64; Comes from '00_export_v4.ipynb'
def compose(*funcs, order=None):
    "Create a function that composes all functions in `funcs`, "\
    "passing along remaining `*args` and `**kwargs` to all"
    if len(funcs)==0: return noop
    if len(funcs)==1: return funcs[0]
    def _inner(x, *args, **kwargs):
        for f in funcs: x = f(x, *args, **kwargs)
        return x
    return _inner


# Cell nr. 65; Comes from '00_export_v4.ipynb'
def last_index(x, o):
    "Finds the last index of occurence of `x` in `o` (returns -1 if no occurence)"
    try: return next(i for i in reversed(range(len(o))) if o[i] == x)
    except StopIteration: return -1